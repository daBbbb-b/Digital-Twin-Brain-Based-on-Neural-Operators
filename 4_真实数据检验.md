下面给出**成员 D（在 103 task 数据集上验证）**的**任务说明文档**，已按项目语境与前面 A/B/C 成员保持一致，结构化、可直接作为执行指南或写入 README / 分工文档。

---

# 成员 D：真实任务态数据负责人（103 Task 数据处理与推断）

## 一、角色定位与总体目标

**成员 D 的核心职责**是：
在 **103 个真实 fMRI task 数据集** 上，完成从 **原始 BOLD 数据 → 模型可用状态变量 (x(t))** 的处理流程，并调用 **成员 C 训练好的神经算子模型**，对每一个 task **反演刺激函数 ( \hat{u}(t) )**。

> 成员 D **不负责**：

* EC 的估计算法设计（成员 B）
* 神经算子模型训练（成员 C）
* 结果可视化与一致性评估（成员 E）

---

## 二、输入与输出一览

### 输入（来自项目其他成员 / 数据集）

1. **103 task fMRI 原始数据**

   * NIfTI：`*_bold.nii.gz`
   * 事件文件：`*_events.tsv`
2. **脑区模板**

   * 如 AAL246 / Brainnetome246（`atlas_246.nii.gz`）
3. **连接矩阵（用于一致性校验或条件输入）**

   * SC（组平均白质连接）
   * EC（成员 B 计算结果）
4. **已训练好的神经算子模型**

   * FNO / DeepONet（来自成员 C）

---

### 输出（成员 D 需交付）

1. **每个 task 的刺激反演结果**

   * ( \hat{u}_{task}(t, r) )，维度示例：

     ```
     [task_id, region_id, time]
     ```
2. **标准化后的模型输入数据**

   * task 级脑区时间序列 ( x(t) )
3. **可供成员 E 使用的数据接口**

   * task → u_hat → 激活模式对齐数据

---

## 三、任务流程总览（逻辑闭环）

```
真实 BOLD
  ↓
脑区级时间序列 x(t)
  ↓
（可选）连接一致性校验
  ↓
神经算子反演
  ↓
task 级刺激函数 u_hat(t)
```

---

## 四、详细任务步骤

---

### Step 1：103 Task fMRI 数据预处理

#### 1.1 BOLD 数据基本处理

假设数据已完成基础预处理（如 OSF 提供的版本），否则需确认是否已包含：

* Slice timing correction
* Motion correction
* 空间标准化（MNI）

成员 D 的最低要求是：

* 能够正确读取 `*_bold.nii.gz`
* 理解数据维度：

  ```
  (X, Y, Z, T)
  ```

---

#### 1.2 皮层体素 → 脑区级时间序列

**核心操作**：
使用 `atlas_246.nii.gz`，将 4D BOLD 投影到 246 个脑区。

**输出形式**：

```text
x_task ∈ R^{246 × T}
```

即：

* 每一行：一个脑区
* 每一列：一个 TR 时间点

> 这是神经算子推断时的 **真实输入 x(t)**。

---

### Step 2：Task 时间段与事件对齐（弱监督）

虽然最终目标是 **无监督反演 u(t)**，但事件信息用于：

* task 分段
* 结果解释与 sanity check

使用 `*_events.tsv`：

* ONSET
* DURATION
* TRIAL_TYPE（103 个 task 标签）

成员 D 需要做到：

* 知道每段 ( x(t) ) 属于哪个 task
* 能够按 task 聚合数据（如 task-averaged response）

---

### Step 3：连接矩阵一致性校验（不重新估计）

成员 D **不重新计算 EC / SC**，但需要完成：

1. **维度一致性检查**

   * EC / SC 是否是 `246 × 246`
2. **空间对齐检查**

   * atlas 编号是否一致
3. **数值 sanity check**

   * 非对称性（EC）
   * 稀疏性 / 强连接分布

> 目的：确保成员 C 的模型输入假设在真实数据上不被破坏。

---

### Step 4：构造神经算子模型输入

对于每一个 task，构造模型推断所需的输入：

#### 标准输入形式（示例）

```python
input = {
    "x": x_task,          # [246, T]
    "connectivity": EC,   # 或 SC
    "meta": {
        "task_id": k,
        "subject": sub_id
    }
}
```

> 成员 D 需严格遵循成员 C 约定的数据接口。

---

### Step 5：运行刺激反演（核心任务）

调用已训练的神经算子模型，执行：

[
\hat{u}(t) = \mathcal{G}_\theta^{-1}(x(t); W)
]

其中：

* ( x(t) )：真实 task BOLD（脑区级）
* ( W )：EC / SC（作为条件）
* ( \mathcal{G}_\theta )：神经算子

---

### Step 6：结果整理与存储

对每个 task，输出：

```text
task_XX/
 ├── u_hat.npy        # [246, T]
 ├── x_input.npy     # [246, T]
 ├── meta.json
```

并提供：

* task 级平均刺激
* 时间峰值刺激
* 脑区排序统计（供成员 E 使用）

---

## 五、关键概念澄清（避免常见误解）

### 1️⃣ 为什么真实任务中 x 和 u 看起来“很像”？

* **x(t)**：BOLD，是神经活动 + 血流卷积后的结果
* **u(t)**：潜在神经刺激 / 外源驱动（模型层）

成员 D 的工作是：

> 在**观测空间（x）**中，借助已学习的动力学结构，反推出**隐空间（u）**

---

### 2️⃣ 成员 D 是否“知道真实 u”？

**不知道，也不需要知道。**

* task 的刺激不是 ground truth
* ( \hat{u} ) 是**模型解释层变量**
* 有效性由 **功能一致性（成员 E）** 验证

---

## 六、成员 D 的最终交付清单

✔ 103 个 task 的脑区级 BOLD 数据
✔ 标准化的神经算子输入数据
✔ 每个 task 的刺激反演结果 ( \hat{u}(t) )
✔ 数据接口文档（供成员 E 使用）

---

## 七、一句话总结成员 D 的工作

> **成员 D 是“真实世界 → 数字大脑”的桥梁：
> 把真实 task fMRI 转换为模型可理解的状态，并反演出每个任务背后的潜在刺激结构。**

如果你愿意，下一步我可以帮你把 **成员 A–E 的任务拼成一张完整项目流程图（含 x/u/EC/SC 流向）**，或者直接生成 **最终课程作业级别的分工说明文档**。
